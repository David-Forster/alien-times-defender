### Game Requirements: Multiplication Tables Trainer (Beta Version)
#### 1. Overview
- **Game Purpose**: Develop a simple computer game to improve players' mental arithmetic skills, specifically focusing on multiplication tables from 2x2 to 12x12 (i.e., all combinations where both factors range from 2 to 12).
- **Target Audience**: Players looking to practice and enhance quick recall of multiplication facts.
- **Core Gameplay Loop**: Present multiplication puzzles sequentially (e.g., "4 x 7="). The player inputs an answer within a time limit. Correct answers reduce difficulty ratings and advance progress; incorrect or timed-out answers increase difficulty. The game adapts puzzle selection to focus on areas of weakness.
- **Version Scope**: Beta version – Keep implementation minimal, focusing on core mechanics. No advanced graphics, multiplayer, or external integrations unless specified.
- **Platform**: Web-based (desktop/mobile browser) with keyboard input for answers, built using Phaser 3 for game loop, rendering, and input handling.
- **Win/Loss Conditions**: No traditional "win" state; the game ends after a fixed number of puzzles or user-initiated exit, showing a summary of competency improvements.
#### 2. Data Structures
- **User-Competency Table**:
  - A table (e.g., JavaScript array of objects) containing all possible multiplication combinations (2x2 to 12x12), resulting in 121 entries (11x11, since 2-12 inclusive).
  - Each entry represents a unique puzzle (e.g., "2x2", "2x3", ..., "12x12"). Treat commutative pairs as the same (e.g., 4x7 is identical to 7x4) to avoid duplication, unless specified otherwise.
  - Properties per entry:
    - **puzzle**: String representation of the puzzle (e.g., "4 x 7").
    - **rating** (Expected Difficulty): Hardcoded integer from 1 (easiest) to 100 (hardest), based on relative difficulty. Examples:
      - Easy: "2 x 2" = 5.
      - Medium: "5 x 5" = 40.
      - Hard: "7 x 8" = 95.
      - [Implement a full hardcoded mapping for all 121 entries; use logical progression where lower numbers are easier, and numbers like 7,8,9,11,12 are harder. Suggestion: Use a formula like `rating = Math.round((a + b) * 4.5 + (Math.max(a,b) in [7,8,9,11,12] ? 20 : 0))` to generate initial values, tuning as needed for 2x2 ≈9 to 12x12 ≈100.]
    - **userRating** (Dynamic Competency): Integer from 1 to 100, initialized to the value of **rating**. This tracks player-specific performance and adjusts over time:
      - Increases (makes "harder") on incorrect answers or timeouts.
      - Decreases (makes "easier"/better competency) on correct answers, with larger decreases for faster responses.
  - Storage: Persist the table locally via `localStorage` (e.g., `localStorage.setItem('competencyTable', JSON.stringify(table))`). Reset option for new players.
#### 3. Gameplay Mechanics
- **Puzzle Presentation**:
  - Display puzzles one at a time in a simple text format (e.g., "4 x 7 = " with an input field), using Phaser's `this.add.text()` for rendering.
  - Time Limit: 25 seconds per puzzle, managed via Phaser's `this.time.addEvent({ delay: 25000, callback: onTimeout })`. If no answer is submitted, treat as incorrect and proceed to the next puzzle.
- **Answer Input and Scoring**:
  - Player inputs a numeric answer (integer only) via keyboard events in Phaser (e.g., `this.input.keyboard.on('keydown')` to capture 0-9 keys and build a string, Enter to submit).
  - If correct:
    - Measure response time (from puzzle display to submission) using `Date.now()` or Phaser's timer.
    - Decrease **userRating** based on speed:
      - Max decrease (e.g., -10 points) if answered in ≤5 seconds.
      - Min decrease (e.g., -1 point) if answered in 20+ seconds (but still within limit).
      - Linear interpolation or tiered system for times in between (e.g., define formula: decrease = -10 + (time / 20) * 9).
    - Cap **userRating** at 1 (minimum).
  - If incorrect or timeout:
    - Increase **userRating** by a small fixed amount (e.g., +5 points).
    - Cap **userRating** at 100 (maximum).
- **Game Session**:
  - A session consists of a sequence of puzzles (e.g., 20-50; configurable).
  - At session end, display a summary:
    - Net improvement/degradation: Calculate total change in **userRating** across all presented puzzles (sum of deltas; positive sum = degradation, negative = improvement).
    - Optionally, show a list or heatmap of puzzles with their before/after **userRating** (e.g., using Phaser rectangles for a simple grid visualization).
- **Puzzle Selection Algorithm**:
  - **Initial Behavior**: In early sessions (e.g., first 1-3 games), select a broad range of puzzles across difficulty levels to baseline player competency (e.g., shuffle the full array).
  - **Adaptive Behavior**: In subsequent selections:
    - Prioritize puzzles where **userRating** is high (indicating struggle), but avoid overwhelming with only the hardest.
    - Reduce frequency of low **userRating** puzzles (easy for the player).
    - If player performs well overall (e.g., average **userRating** < 30), introduce more high-rating puzzles.
    - Algorithm Suggestion: Use weighted random selection where weight = **userRating** (higher = more likely to be selected), implemented via cumulative weights and `Math.random()`. Adjust weights dynamically after each answer.
  - Avoid repetition in a single session unless necessary for focus (track with a session history array).
#### 4. User Interface and Experience
- **Minimal UI**:
  - Main Screen: Display current puzzle, timer countdown (e.g., tweened rectangle bar), input field (live text update), and submit button (or Enter key).
  - Feedback: Immediate after answer (e.g., "Correct! Time: 3s" or "Incorrect. Answer was 28."), with color changes or scale tweens via Phaser.
  - End Screen: Summary of net changes, perhaps a progress bar or table showing updated **userRating** for puzzles encountered, using Phaser scenes for transitions.
- **Accessibility**: Keyboard-friendly input; clear text; optional sound cues for timer/start (via Phaser's `this.sound.play()`).
- **Progress Tracking**: Over multiple sessions, aim for **userRating** to trend downward toward 1 for all puzzles.
#### 5. Technical Requirements
- **Language/Framework**: JavaScript (ES6+) or TypeScript with Phaser 3 as the game framework for handling game loop, input, timers, and Canvas/WebGL rendering. Use Vite as the build tool/bundler for fast development and optimization.
- **Additional Tech Stack Details**:
  - **Game Framework**: Phaser 3 (version 3.90.0 or latest stable) – Provides scenes (e.g., Preload, Menu, Play, Summary), text rendering, event handling, and extensibility.
  - **Build Tool**: Vite – For hot module replacement, ES modules, and bundling (setup via `npm create vite@latest --template vanilla-ts`).
  - **Persistence**: `localStorage` for JSON-serialized competency table.
  - **Audio (Optional)**: Phaser's built-in audio for SFX like timer ticks or feedback chimes.
  - **Deployment**: Static hosting (e.g., GitHub Pages or Netlify) for web distribution.
- **Edge Cases**:
  - Handle invalid inputs (e.g., non-numeric) as incorrect.
  - Ensure no division by zero or invalid operations (not applicable here).
  - Randomize puzzle order within selection logic to keep it engaging.
- **Testing**: Unit tests for rating adjustments, selection algorithm, and persistence (e.g., using Jest with Vite).
- **Extensibility**: Design modularly with Phaser scenes for future expansions (e.g., adding division, higher tables, or basic graphics).